shl_1([Head|Tail], Result) :-
    shl_1_helper(Tail, Head, Result).

shl_1_helper([], Element, [Element]).
shl_1_helper([H|T], Element, [H|Result]) :-
    shl_1_helper(T, Element, Result).


/** <examples>

?- shl_1([1,2,3,4,5], [2,3,4,5,1]) .
?- shl_1([5,5,5,4,5], X) .
?- shl_1([a,b,c], [b,c,X]) .

*/

/* Шо у вас тут происходит?
* 1. Из предиката с двумя переменными делаем предикат с тремя.
*	Зачем? Чтобы иметь возможность опускаться в рекурсию, не теряя части списка.
*    Но как? А вот так, заметим, что в случае True префиксы второго списка и 
*    "первого списка без первого элемента" должны совпадать
* 2. Что делается? Хелпер спускается по рекурсии вниз, оставляя в аргументе всё более
*   короткий список, доходит до факта с пустым списком, и начинает возвращаться
*   по рекурсии вверх, попутно строя циклически смещенный список.
* 3. То есть: 
*   shl_1([1,2,3,4,5], [2,3,4,5,1])
*=> shl_1_helper([2,3,4,5], 1, [2,3,4,5,1])
*=> shl_1_helper([3,4,5], 1, [3,4,5,1])]
*=> shl_1_helper([4,5], 1, [4,5,1])]
*=> shl_1_helper([5], 1, [5,1])]
*=> shl_1_helper([], 1, [1])] -> что-то на фактическом, а значит TRUE
* 
*/